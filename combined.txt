resource "aws_autoscaling_group" "main" {
  count = var.ha_mode ? 1 : 0

  name                = var.name
  max_size            = 1
  min_size            = 1
  desired_capacity    = 1
  health_check_type   = "EC2"
  vpc_zone_identifier = [var.subnet_id]

  launch_template {
    id      = aws_launch_template.main.id
    version = "$Latest"
  }

  dynamic "tag" {
    for_each = lookup(var.tags, "Name", null) == null ? ["Name"] : []

    content {
      key                 = "Name"
      value               = var.name
      propagate_at_launch = true
    }
  }

  dynamic "tag" {
    for_each = var.tags

    content {
      key                 = tag.key
      value               = tag.value
      propagate_at_launch = false
    }
  }

  enabled_metrics = [
    "GroupMinSize",
    "GroupMaxSize",
    "GroupDesiredCapacity",
    "GroupInServiceInstances",
    "GroupPendingInstances",
    "GroupStandbyInstances",
    "GroupTerminatingInstances",
    "GroupTotalInstances",
    "GroupInServiceCapacity",
    "GroupPendingCapacity",
    "GroupStandbyCapacity",
    "GroupTerminatingCapacity",
    "GroupTotalCapacity",
    "WarmPoolDesiredCapacity",
    "WarmPoolWarmedCapacity",
    "WarmPoolPendingCapacity",
    "WarmPoolTerminatingCapacity",
    "WarmPoolTotalCapacity",
    "GroupAndWarmPoolDesiredCapacity",
    "GroupAndWarmPoolTotalCapacity"
  ]

  timeouts {
    delete = "15m"
  }
}
# envs/prod/backend.tf

terraform {
  required_version = ">= 1.3.0"
  required_providers {
    aws = { source = "hashicorp/aws", version = "~> 5.0" }
  }
  backend "s3" {
    bucket         = "kane-backend-bucket"
    key            = "dev/terraform.tfstate"
    region         = "eu-central-1" # Hardcoded region
    dynamodb_table = "kane-terraform-db"
    encrypt        = true
  }
}# envs/dev/backend.tf
terraform {
  required_version = ">= 1.3.0"
  required_providers {
    aws = { source = "hashicorp/aws", version = "~> 5.0" }
    # ADDED: The 'random' provider is needed for the secret name fix.
    random = {
      source  = "hashicorp/random"
      version = "~> 3.5"
    }
  }
  backend "s3" {
    bucket         = "kane-backend-bucket"
    key            = "dev/terraform.tfstate"
    region         = "eu-central-1" # Hardcoded region
    dynamodb_table = "kane-terraform-db"
    encrypt        = true
  }
}# envs/dev/budgets.tf

# COST OPTIMIZATION: Add a budget to monitor costs and send alerts.
resource "aws_budgets_budget" "monthly_ec2" {
  name         = "monthly-ec2-cost-budget"
  budget_type  = "COST"
  limit_amount = "100.0" # Set your desired budget limit
  limit_unit   = "USD"
  time_unit    = "MONTHLY"

  # FIXED: The argument is 'cost_filter' (singular), not 'cost_filters'.
  cost_filter {
    name   = "Service"
    values = ["Amazon Elastic Compute Cloud - Compute"]
  }

  notification {
    comparison_operator        = "GREATER_THAN"
    threshold                  = 80 # Alert at 80% of the budget
    threshold_type             = "PERCENTAGE"
    notification_type          = "FORECASTED"
    subscriber_email_addresses = ["antoni.wlodarski@securitykane.com"] # Replace with your email
  }
}
data "aws_ami" "main" {
  count = var.ami_id != null ? 0 : 1

  most_recent = true
  owners      = ["568608671756"]

  filter {
    name   = "name"
    values = ["fck-nat-al2023-hvm-*"]
  }

  filter {
    name   = "architecture"
    values = [local.is_arm ? "arm64" : "x86_64"]
  }

  filter {
    name   = "root-device-type"
    values = ["ebs"]
  }

  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }
}

data "aws_arn" "ssm_param" {
  count = var.use_cloudwatch_agent && var.cloudwatch_agent_configuration_param_arn != null ? 1 : 0

  arn = var.cloudwatch_agent_configuration_param_arn
}

resource "aws_launch_template" "main" {
  #checkov:skip=CKV_AWS_88:NAT instances must have a public IP.
  name          = var.name
  image_id      = local.ami_id
  instance_type = var.instance_type
  key_name      = var.ssh_key_name

  block_device_mappings {
    device_name = "/dev/xvda"

    ebs {
      volume_size = var.ebs_root_volume_size
      volume_type = "gp3"
      encrypted   = var.encryption
      kms_key_id  = var.kms_key_id
    }
  }

  iam_instance_profile {
    name = aws_iam_instance_profile.main.name
  }

  network_interfaces {
    description                 = "${var.name} ephemeral public ENI"
    subnet_id                   = var.subnet_id
    associate_public_ip_address = true
    security_groups             = local.security_groups
  }

  dynamic "instance_market_options" {
    for_each = var.use_spot_instances ? ["x"] : []

    content {
      market_type = "spot"
    }
  }

  dynamic "tag_specifications" {
    for_each = ["instance", "network-interface", "volume"]

    content {
      resource_type = tag_specifications.value

      tags = merge({ Name = var.name }, var.tags)
    }
  }

  user_data = base64encode(templatefile("${path.module}/templates/user_data.sh", {
    TERRAFORM_ENI_ID                 = aws_network_interface.main.id
    TERRAFORM_EIP_ID                 = length(var.eip_allocation_ids) != 0 ? var.eip_allocation_ids[0] : ""
    TERRAFORM_CWAGENT_ENABLED        = var.use_cloudwatch_agent ? "true" : ""
    TERRAFORM_CWAGENT_CFG_PARAM_NAME = local.cwagent_param_name != null ? local.cwagent_param_name : ""
  }))

  # Enforce IMDSv2
  metadata_options {
    http_endpoint = "enabled"
    http_tokens   = "required"
  }

  tags = var.tags
}

resource "aws_instance" "main" {
  #checkov:skip=CKV2_AWS_41:False positive, IAM role is attached via the launch template.
  count = var.ha_mode ? 0 : 1

  launch_template {
    id      = aws_launch_template.main.id
    version = "$Latest"
  }

  tags = var.tags

  lifecycle {
    ignore_changes = [
      source_dest_check,
      user_data,
      tags
    ]
  }
}
resource "aws_iam_instance_profile" "main" {
  name = var.name
  role = aws_iam_role.main.name

  tags = var.tags
}

data "aws_iam_policy_document" "main" {
  statement {
    sid    = "ManageNetworkInterface"
    effect = "Allow"
    actions = [
      "ec2:AttachNetworkInterface",
      "ec2:ModifyNetworkInterfaceAttribute",
    ]
    resources = [
      "*",
    ]
    condition {
      test     = "StringEquals"
      variable = "ec2:ResourceTag/Name"
      values   = [var.name]
    }
  }

  dynamic "statement" {
    for_each = length(var.eip_allocation_ids) != 0 ? ["x"] : []

    content {
      sid    = "ManageEIPAllocation"
      effect = "Allow"
      actions = [
        "ec2:AssociateAddress",
        "ec2:DisassociateAddress",
      ]
      resources = [
        "arn:aws:ec2:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:elastic-ip/${var.eip_allocation_ids[0]}",
      ]
    }
  }

  dynamic "statement" {
    for_each = length(var.eip_allocation_ids) != 0 ? ["x"] : []

    content {
      sid    = "ManageEIPNetworkInterface"
      effect = "Allow"
      actions = [
        "ec2:AssociateAddress",
        "ec2:DisassociateAddress",
      ]
      resources = [
        "arn:aws:ec2:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:network-interface/*"
      ]
      condition {
        test     = "StringEquals"
        variable = "ec2:ResourceTag/Name"
        values   = [var.name]
      }
    }
  }

  dynamic "statement" {
    for_each = var.use_cloudwatch_agent ? ["x"] : []

    content {
      sid    = "CWAgentSSMParameter"
      effect = "Allow"
      actions = [
        "ssm:GetParameter"
      ]
      resources = [
        local.cwagent_param_arn
      ]
    }
  }

  dynamic "statement" {
    for_each = var.use_cloudwatch_agent ? ["x"] : []

    content {
      sid    = "CWAgentMetrics"
      effect = "Allow"
      actions = [
        "cloudwatch:PutMetricData"
      ]
      resources = [
        "*"
      ]
      condition {
        test     = "StringEquals"
        variable = "cloudwatch:namespace"
        values   = [var.cloudwatch_agent_configuration.namespace]
      }
    }
  }

  dynamic "statement" {
    for_each = var.attach_ssm_policy ? ["x"] : []

    content {
      sid    = "SessionManager"
      effect = "Allow"
      actions = [
        "ssmmessages:CreateDataChannel",
        "ssmmessages:OpenDataChannel",
        "ssmmessages:CreateControlChannel",
        "ssmmessages:OpenControlChannel",
        "ssm:UpdateInstanceInformation",
      ]
      resources = [
        "*"
      ]
    }
  }
}

resource "aws_iam_policy" "main" {
  name   = var.name
  policy = data.aws_iam_policy_document.main.json
  tags   = var.tags
}

data "aws_iam_policy_document" "instance_assume_role_policy" {
  statement {
    actions = ["sts:AssumeRole"]
    principals {
      type        = "Service"
      identifiers = ["ec2.amazonaws.com"]
    }
    effect = "Allow"
  }
}

resource "aws_iam_role" "main" {
  name               = var.name
  assume_role_policy = data.aws_iam_policy_document.instance_assume_role_policy.json
  tags               = var.tags
}

resource "aws_iam_role_policy_attachment" "main" {
  role       = aws_iam_role.main.name
  policy_arn = aws_iam_policy.main.arn
}
# envs/dev/jump_host.tf

resource "aws_security_group_rule" "allow_ssh_to_jump_host" {
  for_each = toset(var.my_ips_for_ssh)

  type              = "ingress"
  from_port         = 22
  to_port           = 22
  protocol          = "tcp"
  cidr_blocks       = [each.key] # Corrected: Use the value directly
  security_group_id = module.vpc.fck_nat_security_group_id
  description       = "Allow SSH from ${each.key} to the jump host"
}


# Rule 2: Allow SSH from the jump host to the Monolith ASG instances.
resource "aws_security_group_rule" "allow_jump_to_monolith" {
  type                     = "ingress"
  from_port                = 22
  to_port                  = 22
  protocol                 = "tcp"
  source_security_group_id = module.vpc.fck_nat_security_group_id
  security_group_id        = module.monolith_asg.security_group_id
  description              = "Allow SSH from jump host to Monolith instances"
}

# Rule 3: Allow SSH from the jump host to the Agentic ASG instances.
resource "aws_security_group_rule" "allow_jump_to_agentic" {
  type                     = "ingress"
  from_port                = 22
  to_port                  = 22
  protocol                 = "tcp"
  source_security_group_id = module.vpc.fck_nat_security_group_id
  security_group_id        = module.agentic_asg.security_group_id
  description              = "Allow SSH from jump host to Agentic instances"
}

resource "aws_security_group_rule" "allow_jump_to_qdrant" {
  type                     = "ingress"
  from_port                = 22
  to_port                  = 22
  protocol                 = "tcp"
  source_security_group_id = module.vpc.fck_nat_security_group_id
  security_group_id        = module.data_services.data_services_security_group_id
  description              = "Allow SSH from jump host to Qdrant instance"
}
locals {
  name_prefix = "${var.project}-${var.environment}-${var.tenant_id}"
}

data "aws_availability_zones" "available" {}
# envs/dev/locals.tf

locals {
  # FIXED: Enforce lowercase on the name_prefix to comply with AWS naming
  # conventions for resources like S3 buckets and ECR repositories.
  name_prefix = lower("${var.project}-${var.environment}-${var.tenant_id}")
}

data "aws_availability_zones" "azs" {}
# modules/agentic_asg/main.tf

###############################################################################
# 1 Security Group
###############################################################################
resource "aws_security_group" "agentic_sg" {
  name        = "${var.name}-agentic-sg"
  description = "Allow web ASG to talk to Agentic logic"
  vpc_id      = var.vpc_id

  dynamic "ingress" {
    for_each = var.allowed_source_security_group_ids
    content {
      from_port       = 80
      to_port         = 80
      protocol        = "tcp"
      security_groups = [ingress.value]
      description     = "Allow web ASG"
    }
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

###############################################################################
# 2 IAM Role & Instance Profile
###############################################################################
# ADDED: Data source to get the current AWS account ID for IAM policy construction.
data "aws_caller_identity" "current" {}

data "aws_iam_policy_document" "assume_ec2" {
  statement {
    actions = ["sts:AssumeRole"]
    principals {
      type        = "Service"
      identifiers = ["ec2.amazonaws.com"]
    }
  }
}

resource "aws_iam_role" "agentic_role" {
  name               = "${var.name}-agentic-role"
  assume_role_policy = data.aws_iam_policy_document.assume_ec2.json
}

resource "aws_iam_role_policy_attachment" "agentic_ssm_policy" {
  role       = aws_iam_role.agentic_role.name
  policy_arn = "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore"
}

# Attaching the read-only ECR policy is the best practice for this.
resource "aws_iam_role_policy_attachment" "agentic_ecr_policy" {
  role       = aws_iam_role.agentic_role.name
  policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
}

# UPDATED: This policy now reflects the least-privilege permissions required.
data "aws_iam_policy_document" "agentic_policy" {
  # This policy grants the Agentic ASG the core permissions it needs to
  # process prompts and generate AI responses.

  statement {
    sid       = "BedrockInvoke"
    effect    = "Allow"
    actions   = ["bedrock:InvokeModel"]
    # Scoped to all models for simplicity, but can be restricted to specific model ARNs.
    resources = ["*"]
  }

  statement {
    sid       = "SecretsManagerRead"
    effect    = "Allow"
    actions   = ["secretsmanager:GetSecretValue"]
    # Allows reading any secret under the application's path.
    # This is necessary to fetch the Qdrant API key and other credentials.
    resources = ["arn:aws:secretsmanager:${var.region}:${data.aws_caller_identity.current.account_id}:secret:/myapp/${var.tenant_id}/*"]
  }

  statement {
    sid    = "CloudWatchLogs"
    effect = "Allow"
    actions = [
      "logs:CreateLogGroup",
      "logs:CreateLogStream",
      "logs:PutLogEvents"
    ]
    # Allows the EC2 instances to write logs for monitoring and debugging.
    resources = ["arn:aws:logs:${var.region}:${data.aws_caller_identity.current.account_id}:log-group:/aws/ec2/${var.name}-*"]
  }
}

resource "aws_iam_role_policy" "agentic_policy" {
  name   = "${var.name}-agentic-inline-policy"
  role   = aws_iam_role.agentic_role.id
  policy = data.aws_iam_policy_document.agentic_policy.json
}
resource "aws_iam_instance_profile" "agentic_profile" {
  name = "${var.name}-agentic-profile"
  role = aws_iam_role.agentic_role.name
}

###############################################################################
# 3 Launch Template
###############################################################################
data "aws_ami" "ubuntu" {
  most_recent = true
  owners      = ["099720109477"] # Canonical's owner ID for Ubuntu

  filter {
    name   = "name"
    # This filter finds the latest Ubuntu 22.04 LTS for ARM64 architecture.
    # Adjust if you need a different version or architecture (e.g., x86_64).
    values = ["ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-arm64-server-*"]
  }

  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }
}

# UPDATED: The launch template now uses the Ubuntu AMI and the new user_data script.
resource "aws_launch_template" "agentic_lt" {
  name_prefix   = "${var.name}-agentic-lt-"
  image_id      = data.aws_ami.ubuntu.id # Use the new Ubuntu AMI
  instance_type = var.instance_type

  iam_instance_profile {
    name = aws_iam_instance_profile.agentic_profile.name
  }

  metadata_options {
    http_tokens   = "required"
    http_endpoint = "enabled"
  }

  network_interfaces {
    device_index                = 0
    subnet_id                   = element(var.private_subnet_ids, 0)
    security_groups             = [aws_security_group.agentic_sg.id]
    associate_public_ip_address = false
  }

  # The user_data is now sourced from a new template file and passes in the secret ARN.
  user_data = base64encode(templatefile("${path.module}/ubuntu_user_data.sh.tpl", {
    db_secret_arn       = var.secrets_manager_secret_arn
    # This now receives the ARN from the new variable passed into the module
    deploy_key_secret_arn = var.deploy_key_secret_arn
    region              = var.region
  }))
}

###############################################################################
# 4 Auto Scaling Group
###############################################################################
resource "aws_autoscaling_group" "agentic_asg" {
  name                = "${var.name}-agentic-asg"
  min_size            = var.min_size
  max_size            = 4
  desired_capacity    = var.desired_capacity
  vpc_zone_identifier = var.private_subnet_ids

  launch_template {
    id      = aws_launch_template.agentic_lt.id
    version = "$Latest"
  }

  health_check_type = "EC2"

  tag {
    key                 = "Name"
    value               = "${var.name}-agentic"
    propagate_at_launch = true
  }
}

###############################################################################
# 5 ECR Repository & CloudWatch Logs
###############################################################################
resource "aws_ecr_repository" "agentic" {
  name = lower("${var.name}-agentic")
}

resource "aws_cloudwatch_log_group" "agentic_asg_logs" {
  name              = "/aws/ec2/${var.name}-agentic"
  retention_in_days = 7
}

###############################################################################
# 6 Auto Scaling Policies
###############################################################################

resource "aws_autoscaling_policy" "scale_up" {
  name                   = "${var.name}-scale-up"
  autoscaling_group_name = aws_autoscaling_group.agentic_asg.name
  adjustment_type        = "ChangeInCapacity"
  scaling_adjustment     = 1
  cooldown               = 300 # 5 minutes
}

resource "aws_cloudwatch_metric_alarm" "scale_up_alarm" {
  alarm_name          = "${var.name}-cpu-high-alarm"
  comparison_operator = "GreaterThanOrEqualToThreshold"
  evaluation_periods  = "1"
  metric_name         = "CPUUtilization"
  namespace           = "AWS/EC2"
  period              = "300" # 5 minutes in seconds
  statistic           = "Average"
  threshold           = "70"

  dimensions = {
    AutoScalingGroupName = aws_autoscaling_group.agentic_asg.name
  }

  alarm_description = "This metric monitors ec2 cpu utilization"
  alarm_actions     = [aws_autoscaling_policy.scale_up.arn]
}

resource "aws_autoscaling_policy" "scale_down" {
  name                   = "${var.name}-scale-down"
  autoscaling_group_name = aws_autoscaling_group.agentic_asg.name
  adjustment_type        = "ChangeInCapacity"
  scaling_adjustment     = -1
  cooldown               = 600 # 10 minutes
}

resource "aws_cloudwatch_metric_alarm" "scale_down_alarm" {
  alarm_name          = "${var.name}-cpu-low-alarm"
  comparison_operator = "LessThanOrEqualToThreshold"
  evaluation_periods  = "1"
  metric_name         = "CPUUtilization"
  namespace           = "AWS/EC2"
  period              = "600" # 10 minutes in seconds
  statistic           = "Average"
  threshold           = "30"

  dimensions = {
    AutoScalingGroupName = aws_autoscaling_group.agentic_asg.name
  }

  alarm_description = "This metric monitors ec2 cpu utilization"
  alarm_actions     = [aws_autoscaling_policy.scale_down.arn]
}
# modules/rag_pipeline/main.tf

###############################################################################
# 1. S3 Buckets & SQS Queues
###############################################################################

# This is the new bucket for direct user uploads.
resource "aws_s3_bucket" "priority_uploads" {
  bucket = "${var.name}-priority-uploads"
}

resource "aws_s3_bucket_cors_configuration" "priority_uploads_cors" {
  bucket = aws_s3_bucket.priority_uploads.id

  cors_rule {
    allowed_headers = ["*"]
    allowed_methods = ["PUT", "POST"]
    allowed_origins = ["*"] # In production, restrict this to your domain
    expose_headers  = ["ETag"]
  }
}

# This existing bucket is now for processed chunks only.
resource "aws_s3_bucket" "rag_chunks" {
  bucket = "${var.name}-rag-chunks"
}

resource "aws_sqs_queue" "dlq" {
  name = "${var.name}-rag-dlq"
}

resource "aws_sqs_queue" "high_priority_queue" {
  name = "${var.name}-high-priority-queue"

  redrive_policy = jsonencode({
    deadLetterTargetArn = aws_sqs_queue.dlq.arn
    maxReceiveCount     = 5
  })
}

# S3 event notification to trigger the SQS queue on new uploads.
resource "aws_s3_bucket_notification" "bucket_notification" {
  bucket = aws_s3_bucket.priority_uploads.id

  queue {
    queue_arn     = aws_sqs_queue.high_priority_queue.arn
    events        = ["s3:ObjectCreated:*"]
  }

  depends_on = [aws_sqs_queue_policy.high_priority_queue_policy]
}
###############################################################################
# 2. Chunk-Splitter Lambda
###############################################################################
resource "aws_iam_role" "chunk_lambda_role" {
  name               = "${var.name}-chunk-lambda-role"
  assume_role_policy = data.aws_iam_policy_document.assume_lambda.json
}

resource "aws_iam_role_policy_attachment" "chunk_vpc_access" {
  role       = aws_iam_role.chunk_lambda_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole"
}

resource "aws_iam_role_policy" "chunk_lambda_policy" {
  name   = "${var.name}-chunk-lambda-policy"
  role   = aws_iam_role.chunk_lambda_role.id
  policy = jsonencode({
    Version   = "2012-10-17",
    Statement = [
      {
        Sid      = "S3ReadUploads",
        Effect   = "Allow",
        Action   = ["s3:GetObject", "s3:GetObjectTagging"],
        Resource = "${aws_s3_bucket.priority_uploads.arn}/*"
      },
      {
        Sid      = "S3PutChunks",
        Effect   = "Allow",
        Action   = ["s3:PutObject", "s3:PutObjectTagging"],
        Resource = "${aws_s3_bucket.rag_chunks.arn}/*"
      },
      {
        Sid    = "SQSRead",
        Effect = "Allow",
        Action = ["sqs:ReceiveMessage", "sqs:DeleteMessage", "sqs:GetQueueAttributes"],

        Resource = [
          aws_sqs_queue.high_priority_queue.arn,
          aws_sqs_queue.low_priority_queue.arn
        ]
      }
    ]
  })
}

resource "aws_lambda_function" "chunk" {
  function_name = "${var.name}-chunk"
  s3_bucket     = var.chunk_lambda_s3_bucket
  s3_key        = var.chunk_lambda_s3_key
  handler       = "chunk.lambda_handler"
  runtime       = "python3.9"
  role          = aws_iam_role.chunk_lambda_role.arn
  timeout       = 15
  memory_size   = 256

  vpc_config {
    subnet_ids         = var.private_subnet_ids
    security_group_ids = [var.lambda_security_group_id]
  }
}

resource "aws_lambda_event_source_mapping" "chunk_trigger" {
  event_source_arn = aws_sqs_queue.high_priority_queue.arn
  function_name    = aws_lambda_function.chunk.arn
}
resource "aws_sqs_queue_policy" "high_priority_queue_policy" {
  queue_url = aws_sqs_queue.high_priority_queue.id
  policy = jsonencode({
    Version = "2012-10-17",
    Statement = [
      {
        Effect    = "Allow",
        Principal = { Service = "s3.amazonaws.com" },
        Action    = "sqs:SendMessage",
        Resource  = aws_sqs_queue.high_priority_queue.arn,
        Condition = {
          ArnEquals = { "aws:SourceArn" = aws_s3_bucket.priority_uploads.arn }
        }
      }
    ]
  })
}
###############################################################################
# 3. Embed & Index Lambda
###############################################################################
resource "aws_iam_role" "embed_index_lambda_role" {
  name               = "${var.name}-embed-index-lambda-role"
  assume_role_policy = data.aws_iam_policy_document.assume_lambda.json
}

resource "aws_iam_role_policy_attachment" "embed_index_vpc_access" {
  role       = aws_iam_role.embed_index_lambda_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole"
}

# UPDATED: Inline policy with the exact permissions required for the Embed & Index Lambda.
resource "aws_iam_role_policy" "embed_index_lambda_policy" {
  name = "${var.name}-embed-index-lambda-policy"
  role = aws_iam_role.embed_index_lambda_role.id
  policy = jsonencode({
    Version   = "2012-10-17",
    Statement = [
      {
        Sid      = "S3ReadChunks",
        Effect   = "Allow",
        Action   = ["s3:GetObject", "s3:GetObjectTagging"],
        Resource = "${aws_s3_bucket.rag_chunks.arn}/*"
      },
      {
        Sid      = "BedrockInvoke",
        Effect   = "Allow",
        Action   = "bedrock:InvokeModel",
        Resource = var.bedrock_embed_model_arn
      },
      {
        Sid      = "SecretsManagerRead",
        Effect   = "Allow",
        Action   = "secretsmanager:GetSecretValue",
        Resource = var.qdrant_api_key_secret_arn
      }
    ]
  })
}

resource "aws_lambda_function" "embed_and_index" {
  function_name = "${var.name}-embed-and-index"
  s3_bucket     = var.embed_lambda_s3_bucket
  s3_key        = var.embed_lambda_s3_key
  handler       = "embed_index.handler"
  runtime       = "python3.9"
  role          = aws_iam_role.embed_index_lambda_role.arn
  timeout       = 30
  memory_size   = 512

  vpc_config {
    subnet_ids         = var.private_subnet_ids
    security_group_ids = [var.lambda_security_group_id]
  }
}

resource "aws_s3_bucket_notification" "chunk_notification" {
  bucket = aws_s3_bucket.rag_chunks.id

  lambda_function {
    lambda_function_arn = aws_lambda_function.embed_and_index.arn
    events              = ["s3:ObjectCreated:*"]
  }
  depends_on = [aws_lambda_permission.allow_s3_invoke_embed_index]

}
resource "aws_lambda_permission" "allow_s3_invoke_embed_index" {
  statement_id  = "AllowS3InvokeEmbedAndIndexLambda"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.embed_and_index.function_name
  principal     = "s3.amazonaws.com"
  source_arn    = aws_s3_bucket.rag_chunks.arn
}

# Common data source used by all Lambda roles
data "aws_iam_policy_document" "assume_lambda" {
  statement {
    actions = ["sts:AssumeRole"]
    principals {
      type        = "Service"
      identifiers = ["lambda.amazonaws.com"]
    }
  }
}

resource "aws_sqs_queue" "low_priority_queue" {
  name = "${var.name}-rag-queue" # This is the original name you wanted

  redrive_policy = jsonencode({
    deadLetterTargetArn = aws_sqs_queue.dlq.arn
    maxReceiveCount     = 5
  })
}

resource "aws_iam_role" "confluence_checker_lambda_role" {
  name               = "${var.name}-confluence-checker-lambda-role"
  assume_role_policy = data.aws_iam_policy_document.assume_lambda.json
}

resource "aws_iam_role_policy_attachment" "confluence_checker_vpc_access" {
  role       = aws_iam_role.confluence_checker_lambda_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole"
}

resource "aws_iam_role_policy" "confluence_checker_lambda_policy" {
  name = "${var.name}-confluence-checker-lambda-policy"
  role = aws_iam_role.confluence_checker_lambda_role.id
  policy = jsonencode({
    Version   = "2012-10-17",
    Statement = [
      {
        Sid      = "SQSSendMessage",
        Effect   = "Allow",
        Action   = "sqs:SendMessage",
        Resource = aws_sqs_queue.low_priority_queue.arn
      },
      {
        Sid      = "SecretsManagerRead",
        Effect   = "Allow",
        Action   = "secretsmanager:GetSecretValue",
        Resource = var.confluence_api_key_secret_arn
      }
    ]
  })
}

resource "aws_lambda_function" "confluence_checker" {
  function_name = "${var.name}-confluence-checker"
  s3_bucket     = var.chunk_lambda_s3_bucket # Assuming same bucket for all lambdas
  s3_key        = var.confluence_checker_lambda_s3_key
  handler       = "confluence_checker.lambda_handler"
  runtime       = "python3.9"
  role          = aws_iam_role.confluence_checker_lambda_role.arn
  timeout       = 300 # Increased timeout for potentially long-running sync checks
  memory_size   = 256

  vpc_config {
    subnet_ids         = var.private_subnet_ids
    security_group_ids = [var.lambda_security_group_id]
  }
}

resource "aws_lambda_event_source_mapping" "chunk_trigger_low_priority" {
  event_source_arn = aws_sqs_queue.low_priority_queue.arn
  function_name    = aws_lambda_function.chunk.arn
}locals {
  is_arm             = can(regex("[a-zA-Z]+\\d+g[a-z]*\\..+", var.instance_type))
  ami_id             = var.ami_id != null ? var.ami_id : data.aws_ami.main[0].id
  cwagent_param_arn  = var.use_cloudwatch_agent ? var.cloudwatch_agent_configuration_param_arn != null ? var.cloudwatch_agent_configuration_param_arn : aws_ssm_parameter.cloudwatch_agent_config[0].arn : null
  cwagent_param_name = var.use_cloudwatch_agent ? var.cloudwatch_agent_configuration_param_arn != null ? split("/", data.aws_arn.ssm_param[0].resource)[1] : aws_ssm_parameter.cloudwatch_agent_config[0].name : null
  security_groups    = concat(var.use_default_security_group ? [aws_security_group.main.id] : [], var.additional_security_group_ids)
}

data "aws_region" "current" {}
data "aws_caller_identity" "current" {}

data "aws_vpc" "main" {
  id = var.vpc_id
}

resource "aws_security_group" "main" {
  #checkov:skip=CKV_AWS_24:False positive from Checkov, ingress CIDR blocks on port 22 default to "[]"
  name        = var.name
  description = "Used in ${var.name} instance of fck-nat in subnet ${var.subnet_id}"
  vpc_id      = data.aws_vpc.main.id

  ingress {
    description = "Unrestricted ingress from within VPC"
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = data.aws_vpc.main.cidr_block_associations[*].cidr_block
  }

  dynamic "ingress" {
    for_each = var.use_ssh && (length(var.ssh_cidr_blocks.ipv4) > 0 || length(var.ssh_cidr_blocks.ipv6) > 0) ? [1] : [] #  

    content {
      description      = "SSH access"
      from_port        = 22
      to_port          = 22
      protocol         = "tcp"
      cidr_blocks      = var.ssh_cidr_blocks.ipv4
      ipv6_cidr_blocks = var.ssh_cidr_blocks.ipv6
    }
  }

  egress {
    description      = "Unrestricted egress"
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  tags = merge({ Name = var.name }, var.tags)
}

resource "aws_network_interface" "main" {
  description       = "${var.name} static private ENI"
  subnet_id         = var.subnet_id
  security_groups   = [aws_security_group.main.id]
  source_dest_check = false

  tags = merge({ Name = var.name }, var.tags)
}

resource "aws_route" "main" {
  for_each = var.update_route_tables || var.update_route_table ? merge(var.route_tables_ids, var.route_table_id != null ? { RESERVED_FKC_NAT = var.route_table_id } : {}) : {}

  route_table_id         = each.value
  destination_cidr_block = "0.0.0.0/0"
  network_interface_id   = aws_network_interface.main.id
}

resource "aws_ssm_parameter" "cloudwatch_agent_config" {
  count = var.use_cloudwatch_agent && var.cloudwatch_agent_configuration_param_arn == null ? 1 : 0

  name   = "${var.name}-cloudwatch-agent-config"
  key_id = var.kms_key_id
  type   = "SecureString"
  value = templatefile("${path.module}/templates/cwagent.json", {
    METRICS_COLLECTION_INTERVAL = var.cloudwatch_agent_configuration.collection_interval,
    METRICS_NAMESPACE           = var.cloudwatch_agent_configuration.namespace
    METRICS_ENDPOINT_OVERRIDE   = var.cloudwatch_agent_configuration.endpoint_override
  })
}locals {
  name     = "fck-nat-example"
  vpc_cidr = "10.255.255.0/24"
}

data "aws_region" "current" {}

module "fck-nat" {
  source = "../../"

  name      = local.name
  vpc_id    = aws_vpc.main.id
  subnet_id = aws_subnet.public.id
  ha_mode   = true

  update_route_tables = true
  route_tables_ids = {
    "private" = aws_route_table.private.id
  }
}locals {
  name     = "fck-nat-allazs"
  vpc_cidr = "10.255.0.0/16"
}

data "aws_region" "current" {}

data "aws_availability_zones" "azs" {
  state = "available"
  filter {
    name   = "opt-in-status"
    values = ["opt-in-not-required"]
  }
}

module "fck-nat" {
  source   = "../../"
  for_each = toset(data.aws_availability_zones.azs.zone_ids)

  name      = "${local.name}-${each.key}"
  vpc_id    = aws_vpc.main.id
  subnet_id = aws_subnet.public[each.key].id
  # ha_mode              = true
  # use_cloudwatch_agent = true
  # use_spot_instances   = true
  # instance_type        = "t4g.nano"

  update_route_tables = true
  route_tables_ids = {
    private = aws_route_table.private[each.key].id
  }

  tags = {
    Name = "${local.name}-${each.key}"
  }
}
# modules/vpc/main.tf

resource "aws_vpc" "this" {
  cidr_block           = var.cidr
  enable_dns_hostnames = true
  tags                 = { Name = "${var.name}-vpc" }
}

data "aws_availability_zones" "azs" {}

resource "aws_subnet" "public" {
  count                   = length(var.public_subnet_cidrs)
  vpc_id                  = aws_vpc.this.id
  availability_zone       = data.aws_availability_zones.azs.names[count.index]
  cidr_block              = var.public_subnet_cidrs[count.index]
  map_public_ip_on_launch = true
  tags                    = { Name = "${var.name}-public-${count.index}" }
}

resource "aws_subnet" "private_app" {
  count             = length(var.private_app_subnet_cidrs)
  vpc_id            = aws_vpc.this.id
  availability_zone = data.aws_availability_zones.azs.names[count.index]
  cidr_block        = var.private_app_subnet_cidrs[count.index]
  tags              = { Name = "${var.name}-priv-app-${count.index}" }
}

resource "aws_subnet" "private_rag" {
  count             = length(var.private_rag_subnet_cidrs)
  vpc_id            = aws_vpc.this.id
  availability_zone = data.aws_availability_zones.azs.names[count.index]
  cidr_block        = var.private_rag_subnet_cidrs[count.index]
  tags              = { Name = "${var.name}-priv-rag-${count.index}" }
}

# 2 Internet Gateway & Public Route Table
resource "aws_internet_gateway" "igw" {
  vpc_id = aws_vpc.this.id
  tags   = { Name = "${var.name}-igw" }
}

resource "aws_route_table" "public" {
  vpc_id = aws_vpc.this.id
  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.igw.id
  }
  tags = { Name = "${var.name}-public-rt" }
}

resource "aws_route_table_association" "public_assoc" {
  count          = length(var.public_subnet_cidrs)
  subnet_id      = aws_subnet.public[count.index].id
  route_table_id = aws_route_table.public.id
}

# 3. fck-nat Module for cost-effective NAT
module "fck_nat" {
  source = "github.com/RaJiska/terraform-aws-fck-nat"

  name      = "${var.name}-fck-nat"
  vpc_id    = aws_vpc.this.id
  subnet_id = aws_subnet.public[0].id
  ha_mode   = false

  update_route_tables = false
}

# 4. Private Route Table
resource "aws_route_table" "private" {
  vpc_id = aws_vpc.this.id
  tags   = { Name = "${var.name}-private-rt" }
}

resource "aws_route" "private_nat_route" {
  route_table_id         = aws_route_table.private.id
  destination_cidr_block = "0.0.0.0/0"
  network_interface_id   = module.fck_nat.eni_id
}

# Associate the private route table with the private subnets
resource "aws_route_table_association" "private_app_assoc" {
  count          = length(var.private_app_subnet_cidrs)
  subnet_id      = aws_subnet.private_app[count.index].id
  route_table_id = aws_route_table.private.id
}

resource "aws_route_table_association" "private_rag_assoc" {
  count          = length(var.private_rag_subnet_cidrs)
  subnet_id      = aws_subnet.private_rag[count.index].id
  route_table_id = aws_route_table.private.id
}


# 5. VPC Endpoints
resource "aws_security_group" "vpc_endpoint_sg" {
  name        = "${var.name}-vpc-endpoint-sg"
  description = "Allow HTTPS from within the VPC to interface endpoints"
  vpc_id      = aws_vpc.this.id

  ingress {
    description = "Allow HTTPS from VPC"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = [aws_vpc.this.cidr_block]
  }
}

# ADDED: A dedicated security group for the RAG Lambdas.
resource "aws_security_group" "rag_lambda_sg" {
  name        = "${var.name}-rag-lambda-sg"
  description = "Allow outbound traffic from RAG Lambdas"
  vpc_id      = aws_vpc.this.id

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "${var.name}-rag-lambda-sg"
  }
}

resource "aws_vpc_endpoint" "s3" {
  vpc_id            = aws_vpc.this.id
  service_name      = "com.amazonaws.${var.region}.s3"
  vpc_endpoint_type = "Gateway"
  route_table_ids   = [aws_route_table.public.id, aws_route_table.private.id]
}

resource "aws_vpc_endpoint" "secrets" {
  vpc_id              = aws_vpc.this.id
  service_name        = "com.amazonaws.${var.region}.secretsmanager"
  vpc_endpoint_type   = "Interface"
  private_dns_enabled = true
  subnet_ids          = aws_subnet.private_app[*].id
  security_group_ids  = [aws_security_group.vpc_endpoint_sg.id]
}

resource "aws_vpc_endpoint" "logs" {
  vpc_id              = aws_vpc.this.id
  service_name        = "com.amazonaws.${var.region}.logs"
  vpc_endpoint_type   = "Interface"
  private_dns_enabled = true
  subnet_ids          = aws_subnet.private_app[*].id
  security_group_ids  = [aws_security_group.vpc_endpoint_sg.id]
}

resource "aws_security_group" "alb_sg" {
  name        = "${var.name}-alb-sg"
  description = "Allow HTTPS inbound traffic to ALB"
  vpc_id      = aws_vpc.this.id

  ingress {
    description = "Allow HTTPS from anywhere"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "${var.name}-alb-sg"
  }
}
data "aws_iam_policy_document" "assume_ec2" {
  statement {
    effect = "Allow"
    principals {
      type        = "Service"
      identifiers = ["ec2.amazonaws.com"]
    }
    actions = ["sts:AssumeRole"]
  }
}

resource "aws_iam_role" "agentic_role" {
  name               = "${var.name}-agentic-role"
  assume_role_policy = data.aws_iam_policy_document.assume_ec2.json
}

data "aws_iam_policy_document" "agentic_policy" {
  statement {
    sid      = "AllowBedrock"
    effect   = "Allow"
    actions  = ["bedrock:*"]
    resources = ["*"]
  }
  statement {
    sid      = "AllowS3"
    effect   = "Allow"
    actions  = [
      "s3:PutObject",
      "s3:GetObject",
      "s3:ListBucket"
    ]
    resources = [
      "arn:aws:s3:::${var.s3_bucket_name}",
      "arn:aws:s3:::${var.s3_bucket_name}/*"
    ]
  }
  statement {
    sid      = "AllowSQS"
    effect   = "Allow"
    actions  = ["sqs:SendMessage"]
    resources = [var.sqs_queue_arn]
  }
  statement {
    sid      = "AllowSecrets"
    effect   = "Allow"
    actions  = ["secretsmanager:GetSecretValue"]
    resources = [var.secrets_manager_secret_arn]
  }
  statement {
    sid      = "AllowCloudWatchLogs"
    effect   = "Allow"
    actions  = [
      "logs:CreateLogGroup",
      "logs:CreateLogStream",
      "logs:PutLogEvents"
    ]
    resources = ["arn:aws:logs:${var.region}:*:log-group:/aws/ec2/${var.name}-agentic*"]
  }
  statement {
    sid      = "AllowXRay"
    effect   = "Allow"
    actions  = [
      "xray:PutTraceSegments",
      "xray:PutTelemetryRecords",
      "xray:PutInsightEvents"
    ]
    resources = ["*"]
  }
}

resource "aws_iam_role_policy" "agentic_policy" {
  name   = "${var.name}-agentic-policy"
  role   = aws_iam_role.agentic_role.id
  policy = data.aws_iam_policy_document.agentic_policy.json
}

resource "aws_iam_instance_profile" "agentic_profile" {
  name = "${var.name}-agentic-profile"
  role = aws_iam_role.agentic_role.name
}
# modules/monolith_asg/main.tf

###############################################################################
# 1 Monolith EC2 Security Group
###############################################################################
resource "aws_security_group" "monolith" {
  name        = "${var.name}-sg"
  description = "Allow HTTP inbound to Monolith (React + Supertokens)"
  vpc_id      = var.vpc_id

  ingress {
    from_port       = 80
    to_port         = 80
    protocol        = "tcp"
    security_groups = [var.alb_security_group_id] # Changed from cidr_blocks
    description     = "Allow traffic from ALB"
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}
###############################################################################
# 2 Launch Template
###############################################################################
data "aws_ami" "linux_arm" {
  owners      = ["amazon"]
  most_recent = true
  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-arm64-gp2"]
  }
}

resource "aws_launch_template" "monolith" {
  name_prefix   = "${var.name}-lt-"
  image_id      = data.aws_ami.linux_arm.id
  instance_type = var.instance_type

  iam_instance_profile {
    name = aws_iam_instance_profile.monolith_profile.name
  }

  metadata_options {
    http_tokens   = "required"
    http_endpoint = "enabled"
  }

  network_interfaces {
    subnet_id                   = element(var.private_subnet_ids, 0)
    security_groups             = [aws_security_group.monolith.id]
    associate_public_ip_address = false
  }

  user_data = base64encode(templatefile("${path.module}/user_data.sh.tpl", {
    region             = var.region
    monolith_image_uri = var.monolith_image_uri
  }))
}

###############################################################################
# 3 ASG
###############################################################################
resource "aws_autoscaling_group" "monolith_asg" {
  name = "${var.name}-asg"
  launch_template {
    id      = aws_launch_template.monolith.id
    version = "$Latest"
  }
  min_size            = var.min_size
  max_size            = 4
  desired_capacity    = var.desired_capacity
  vpc_zone_identifier = var.private_subnet_ids
  target_group_arns = [var.target_group_arn]

  health_check_type = "EC2"

  tag {
    key                 = "Name"
    value               = "${var.name}-monolith"
    propagate_at_launch = true
  }
}


##################################################################
### IAM Role for Monolith EC2 ###
##################################################################
data "aws_caller_identity" "current" {}
data "aws_region" "current" {}

data "aws_iam_policy_document" "monolith_assume" {
  statement {
    actions = ["sts:AssumeRole"]
    principals {
      type        = "Service"
      identifiers = ["ec2.amazonaws.com"]
    }
  }
}

resource "aws_iam_role" "monolith_role" {
  name               = "${var.name}-monolith-role"
  assume_role_policy = data.aws_iam_policy_document.monolith_assume.json
}

# ADDED: Attaching the specified managed policies directly to the role.
resource "aws_iam_role_policy_attachment" "ssm_core" {
  role       = aws_iam_role.monolith_role.name
  policy_arn = "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore"
}

resource "aws_iam_role_policy_attachment" "ecs_for_ec2" {
  role       = aws_iam_role.monolith_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role"
}

resource "aws_iam_role_policy_attachment" "ecr_read_only" {
  role       = aws_iam_role.monolith_role.name
  policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
}


# UPDATED: Replaced the previous broad policy with the new least-privilege inline policy.
data "aws_iam_policy_document" "monolith_policy" {
  # This policy grants the Monolith (UI) ASG the permissions it needs to
  # serve the frontend, interact with the backend, and manage assets.

  statement {
    sid    = "APIGatewayInvoke"
    effect = "Allow"
    actions = [
      "execute-api:Invoke"
    ]
    # Allows the monolith's backend to call the API Gateway endpoint
    # to initiate the secure file upload process.
    resources = ["arn:aws:execute-api:${var.region}:${data.aws_caller_identity.current.account_id}:*/*"]
  }

  statement {
    sid    = "AppS3Access"
    effect = "Allow"
    actions = [
      "s3:GetObject",
      "s3:PutObject"
    ]
    # Allows the application to read and write its own static assets,
    # such as images, CSS, or user-generated content for the UI.
    resources = [
      "arn:aws:s3:::${var.assets_bucket}",
      "arn:aws:s3:::${var.assets_bucket}/*"
    ]
  }

  statement {
    sid    = "AppSecretsAccess"
    effect = "Allow"
    actions = [
      "secretsmanager:GetSecretValue"
    ]
    # Allows the application to fetch its own necessary secrets,
    # like database passwords or third-party API keys.
    resources = ["arn:aws:secretsmanager:${var.region}:${data.aws_caller_identity.current.account_id}:secret:/myapp/${var.tenant_id}/*"]
  }

  statement {
    sid    = "CloudWatchLogs"
    effect = "Allow"
    actions = [
      "logs:CreateLogGroup",
      "logs:CreateLogStream",
      "logs:PutLogEvents"
    ]
    # Allows the EC2 instances to write application and system logs.
    resources = ["arn:aws:logs:${var.region}:${data.aws_caller_identity.current.account_id}:log-group:/aws/ec2/${var.name}-*"]
  }
}

resource "aws_iam_role_policy" "monolith_policy" {
  name   = "${var.name}-monolith-inline-policy"
  role   = aws_iam_role.monolith_role.id
  policy = data.aws_iam_policy_document.monolith_policy.json
}

resource "aws_iam_instance_profile" "monolith_profile" {
  name = "${var.name}-monolith-profile"
  role = aws_iam_role.monolith_role.name
}

###############################################################################
# 5 ECR Repository
###############################################################################
resource "aws_ecr_repository" "monolith" {
  name = lower("${var.name}-monolith")
}

###############################################################################
# 6 Auto Scaling Policies
###############################################################################

resource "aws_autoscaling_policy" "scale_up" {
  name                   = "${var.name}-scale-up"
  autoscaling_group_name = aws_autoscaling_group.monolith_asg.name
  adjustment_type        = "ChangeInCapacity"
  scaling_adjustment     = 1
  cooldown               = 300 # 5 minutes
}

resource "aws_cloudwatch_metric_alarm" "scale_up_alarm" {
  alarm_name          = "${var.name}-cpu-high-alarm"
  comparison_operator = "GreaterThanOrEqualToThreshold"
  evaluation_periods  = "1"
  metric_name         = "CPUUtilization"
  namespace           = "AWS/EC2"
  period              = "300" # 5 minutes in seconds
  statistic           = "Average"
  threshold           = "70"

  dimensions = {
    AutoScalingGroupName = aws_autoscaling_group.monolith_asg.name
  }

  alarm_description = "This metric monitors ec2 cpu utilization"
  alarm_actions     = [aws_autoscaling_policy.scale_up.arn]
}

resource "aws_autoscaling_policy" "scale_down" {
  name                   = "${var.name}-scale-down"
  autoscaling_group_name = aws_autoscaling_group.monolith_asg.name
  adjustment_type        = "ChangeInCapacity"
  scaling_adjustment     = -1
  cooldown               = 600 # 10 minutes
}

resource "aws_cloudwatch_metric_alarm" "scale_down_alarm" {
  alarm_name          = "${var.name}-cpu-low-alarm"
  comparison_operator = "LessThanOrEqualToThreshold"
  evaluation_periods  = "1"
  metric_name         = "CPUUtilization"
  namespace           = "AWS/EC2"
  period              = "600" # 10 minutes in seconds
  statistic           = "Average"
  threshold           = "30"

  dimensions = {
    AutoScalingGroupName = aws_autoscaling_group.monolith_asg.name
  }

  alarm_description = "This metric monitors ec2 cpu utilization"
  alarm_actions     = [aws_autoscaling_policy.scale_down.arn]
}
# modules/ingress/main.tf

###############################################################################
# 1. API Gateway
###############################################################################
resource "aws_api_gateway_rest_api" "this" {
  name        = "${var.name}-api"
  description = "API Gateway for secure uploads and other interactions."
}

resource "aws_api_gateway_resource" "upload" {
  rest_api_id = aws_api_gateway_rest_api.this.id
  parent_id   = aws_api_gateway_rest_api.this.root_resource_id
  path_part   = "upload"
}

resource "aws_api_gateway_method" "upload_post" {
  rest_api_id   = aws_api_gateway_rest_api.this.id
  resource_id   = aws_api_gateway_resource.upload.id
  http_method   = "POST"
  authorization = "NONE" # In a real scenario, this would be linked to a Lambda Authorizer
}

###############################################################################
# 2. Generate Pre-signed URL Lambda
###############################################################################
resource "aws_iam_role" "presigned_url_lambda_role" {
  name               = "${var.name}-presigned-url-lambda-role"
  assume_role_policy = data.aws_iam_policy_document.assume_lambda.json
}

# ADDED: Standard managed policy for CloudWatch logging.
resource "aws_iam_role_policy_attachment" "lambda_logging" {
  role       = aws_iam_role.presigned_url_lambda_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
}

# UPDATED: Inline policy with least-privilege permissions for S3 and Secrets Manager.
resource "aws_iam_role_policy" "presigned_url_lambda_policy" {
  name   = "${var.name}-presigned-url-lambda-policy"
  role   = aws_iam_role.presigned_url_lambda_role.id
  policy = jsonencode({
    Version   = "2012-10-17",
    Statement = [
      {
        Sid      = "AllowS3Put",
        Effect   = "Allow",
        Action   = "s3:PutObject",
        Resource = "${var.priority_uploads_bucket_arn}/*"
      },
      {
        Sid      = "AllowSecretsRead",
        Effect   = "Allow",
        Action   = "secretsmanager:GetSecretValue",
        Resource = var.jwt_secret_arn
      }
    ]
  })
}

resource "aws_lambda_function" "generate_presigned_url" {
  function_name    = "${var.name}-generate-presigned-url"
  s3_bucket        = var.lambda_code_bucket
  s3_key           = "generate_presigned_url.zip" # Placeholder for your Lambda code
  handler          = "index.handler"
  runtime          = "nodejs18.x" # Example runtime
  role             = aws_iam_role.presigned_url_lambda_role.arn
  timeout          = 10
  memory_size      = 128

  environment {
    variables = {
      PRIORITY_UPLOADS_BUCKET = var.priority_uploads_bucket_id
      # UPDATED: Pass the ARN of the secret, not the secret itself.
      JWT_SECRET_ARN          = var.jwt_secret_arn
    }
  }
}

###############################################################################
# 3. API Gateway Integration
###############################################################################
resource "aws_api_gateway_integration" "lambda" {
  rest_api_id             = aws_api_gateway_rest_api.this.id
  resource_id             = aws_api_gateway_resource.upload.id
  http_method             = aws_api_gateway_method.upload_post.http_method
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.generate_presigned_url.invoke_arn
}

resource "aws_lambda_permission" "apigw" {
  statement_id  = "AllowAPIGatewayInvoke"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.generate_presigned_url.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "${aws_api_gateway_rest_api.this.execution_arn}/*/*"
}

###############################################################################
# 4. Common Resources
###############################################################################
data "aws_iam_policy_document" "assume_lambda" {
  statement {
    actions = ["sts:AssumeRole"]
    principals {
      type        = "Service"
      identifiers = ["lambda.amazonaws.com"]
    }
  }
}

resource "aws_lb" "this" {
  name               = "${var.name}-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [var.alb_security_group_id]
  subnets            = var.public_subnet_ids

  enable_deletion_protection = false
}

resource "aws_lb_target_group" "monolith" {
  name     = "${var.name}-monolith-tg"
  port     = 80 # The port your monolith app listens on
  protocol = "HTTP"
  vpc_id   = var.vpc_id

  health_check {
    path                = "/" # A simple health check path
    protocol            = "HTTP"
    matcher             = "200"
    interval            = 30
    timeout             = 5
    healthy_threshold   = 2
    unhealthy_threshold = 2
  }
}

resource "aws_lb_listener" "https" {
  load_balancer_arn = aws_lb.this.arn
  port              = 443
  protocol          = "HTTPS"
  ssl_policy        = "ELBSecurityPolicy-2016-08"
  # NOTE: You must have a valid ACM certificate for your domain.
  # Replace this with your actual certificate ARN.
  certificate_arn   = var.acm_certificate_arn

  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.monolith.arn
  }
}
# modules/data_services/main.tf

###############################################################################
# 0 Security Group for Data Services
###############################################################################
resource "aws_security_group" "data_services_sg" {
  name        = "${var.name}-data-sg"
  description = "Allow Agentic ASG to access Qdrant on port 6333"
  vpc_id      = var.vpc_id

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

###############################################################################
# 1 Qdrant on EC2
###############################################################################

data "aws_ami" "ecs_optimized_arm" {
  most_recent = true
  owners      = ["amazon"]
  filter {
    name   = "name"
    values = ["amzn2-ami-ecs-hvm-*-arm64-ebs"]
  }
}

resource "aws_iam_role" "qdrant_ec2_role" {
  name = "${var.name}-qdrant-ec2-role"
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "ec2.amazonaws.com"
        }
      },
    ]
  })
}

resource "aws_iam_role_policy_attachment" "qdrant_ssm_policy" {
  role       = aws_iam_role.qdrant_ec2_role.name
  policy_arn = "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore"
}

resource "aws_iam_role_policy_attachment" "qdrant_ecr_pull_policy" {
  role       = aws_iam_role.qdrant_ec2_role.name
  policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
}

resource "aws_iam_instance_profile" "qdrant_ec2_profile" {
  name = "${var.name}-qdrant-ec2-profile"
  role = aws_iam_role.qdrant_ec2_role.name
}

resource "aws_instance" "qdrant" {
  ami                  = data.aws_ami.ecs_optimized_arm.id
  # FIXED: Use the new variable for the instance type.
  instance_type        = var.qdrant_instance_type
  subnet_id            = var.private_subnet_ids[0]
  vpc_security_group_ids = [aws_security_group.data_services_sg.id]
  iam_instance_profile = aws_iam_instance_profile.qdrant_ec2_profile.name

  metadata_options {
    http_tokens   = "required"
    http_endpoint = "enabled"
  }

  root_block_device {
    volume_size = 30
  }

  user_data = <<-EOF
              #!/bin/bash
              # Create Docker daemon configuration file
              cat <<'EOT' > /etc/docker/daemon.json
              {
                "log-driver": "awslogs",
                "log-opts": {
                  "awslogs-group": "${var.name}-qdrant-ec2-logs",
                  "awslogs-region": "${var.region}",
                  "awslogs-create-group": "true"
                }
              }
              EOT

              # Restart Docker to apply the new configuration
              systemctl restart docker

              # Run Qdrant container, which will now log to CloudWatch automatically
              mkdir -p /opt/qdrant/storage
              docker run -d -p 6333:6333 -v /opt/qdrant/storage:/qdrant/storage qdrant/qdrant:latest
              EOF

  tags = {
    Name = "${var.name}-qdrant-ec2"
  }
}

###############################################################################
# 2 Secrets Manager
###############################################################################
resource "random_pet" "secret_suffix" {
  length = 2
}

resource "aws_secretsmanager_secret" "this" {
  for_each                = var.secrets
  name                    = "/myapp/${var.tenant_id}/${each.key}-${random_pet.secret_suffix.id}"
  description             = "Auto-generated secret for ${each.key}"
  recovery_window_in_days = 0
}

resource "aws_secretsmanager_secret_version" "this" {
  for_each      = var.secrets
  secret_id     = aws_secretsmanager_secret.this[each.key].id
  secret_string = each.value
}
# envs/prod/main.tf

module "vpc" {
  source                   = "../../modules/vpc"
  name                     = local.name_prefix
  cidr                     = var.vpc_cidr
  public_subnet_cidrs      = var.public_subnet_cidrs
  private_app_subnet_cidrs = var.private_app_subnet_cidrs
  private_rag_subnet_cidrs = var.private_rag_subnet_cidrs
}
/*
module "ingress" {
  source                  = "../../modules/ingress"
  name                    = local.name_prefix
  vpc_id                  = module.vpc.vpc_id
  public_subnet_ids       = module.vpc.public_subnet_ids
  alb_security_group_id   = module.vpc.alb_sg_id       # from your vpc module outputs
  api_gateway_sg_id       = module.vpc.api_gw_sg_id    # if defined
  domain_name             = "${var.tenant_id}.api.${var.project}.com"
}
*/
module "monolith_asg" {
  source                  = "../../modules/monolith_asg"
  name                    = "${local.name_prefix}-web"
  vpc_id                  = module.vpc.vpc_id
  private_subnet_ids      = module.vpc.private_app_subnet_ids
  instance_type           = var.web_instance_type
  min_size                = var.web_min_size
  max_size                = var.web_max_size
  desired_capacity        = var.web_desired_capacity
  #assets_bucket           = module.data_services.assets_bucket_name # if used in userdata
  # Add missing variables required by the module
  sqs_queue_arn              = module.rag_pipeline.queue_arn
  secrets_manager_secret_arn = element(module.data_services.secrets_manager_secret_arns, 0)
}

module "agentic_asg" {
  source                            = "../../modules/agentic_asg"
  name                              = "${local.name_prefix}-agentic"
  vpc_id                            = module.vpc.vpc_id
  private_subnet_ids                = module.vpc.private_app_subnet_ids

  allowed_source_security_group_ids = [
    module.monolith_asg.security_group_id
  ]

  instance_type                     = var.agentic_instance_type
  min_size                          = var.agentic_min_size
  max_size                          = var.agentic_max_size
  desired_capacity                  = var.agentic_desired_capacity

  s3_bucket_name                    = module.data_services.bucket_name
  sqs_queue_arn                     = module.rag_pipeline.queue_arn
  sqs_queue_url                     = module.rag_pipeline.queue_url
  secrets_manager_secret_arn        = module.data_services.secrets_manager_secret_arns[0]
  region                            = var.region
}

module "data_services" {
  source              = "../../modules/data_services"
  name                = local.name_prefix
  tenant_id           = var.tenant_id
  vpc_id              = module.vpc.vpc_id
  private_subnet_ids  = module.vpc.private_app_subnet_ids
  region              = var.region

  # example: pass initial secrets if you want auto-creation
  secrets = {
    "db_password" = "changeme123"
  }
}

module "rag_pipeline" {
  source                         = "../../modules/rag_pipeline"
  name                           = local.name_prefix
  tenant_id                      = var.tenant_id
  region                         = var.region
  private_subnet_ids             = module.vpc.private_rag_subnet_ids
  vpc_id               = module.vpc.vpc_id  
  chunk_lambda_s3_bucket         = var.chunk_lambda_s3_bucket
  chunk_lambda_s3_key            = var.chunk_lambda_s3_key
  embed_lambda_s3_bucket         = var.embed_lambda_s3_bucket
  embed_lambda_s3_key            = var.embed_lambda_s3_key
  index_lambda_s3_bucket         = var.index_lambda_s3_bucket
  index_lambda_s3_key            = var.index_lambda_s3_key
  secrets_manager_secret_arn     = element(module.data_services.secrets_manager_secret_arns, 0)
}


module "iam" {
  source                  = "../../modules/iam"
  # any shared IAM roles or policies your other modules need
}
/*
module "monitoring" {
  source                  = "../../modules/monitoring"
  name                    = local.name_prefix
  # pass ARNs or names of your ASGs, ALB, Lambdas, etc., to hook up alarms
}
*/
resource "aws_security_group_rule" "agentic_to_data_redis" {
  type                     = "ingress"
  from_port                = 6379
  to_port                  = 6379
  protocol                 = "tcp"
  source_security_group_id = module.agentic_asg.security_group_id
  security_group_id        = module.data_services.data_services_security_group_id
  description              = "Allow Agentic ASG to Redis"
}

resource "aws_security_group_rule" "agentic_to_data_qdrant" {
  type                     = "ingress"
  from_port                = 6333
  to_port                  = 6333
  protocol                 = "tcp"
  source_security_group_id = module.agentic_asg.security_group_id
  security_group_id        = module.data_services.data_services_security_group_id
  description              = "Allow Agentic ASG to Qdrant"
}# envs/dev/main.tf
resource "aws_s3_object" "generate_presigned_url_lambda_code" {
  bucket = aws_s3_bucket.lambda_code.id
  key    = "generate_presigned_url.zip" # This should match the key in your ingress module
  source = data.archive_file.dummy_lambda_zip.output_path
  etag   = filemd5(data.archive_file.dummy_lambda_zip.output_path)
}

resource "aws_s3_object" "confluence_checker_lambda_code" {
  bucket = aws_s3_bucket.lambda_code.id
  key    = var.confluence_checker_lambda_s3_key
  source = data.archive_file.dummy_lambda_zip.output_path
  etag   = filemd5(data.archive_file.dummy_lambda_zip.output_path)
}

resource "aws_iam_role" "scheduler_role" {
  name = "${local.name_prefix}-scheduler-role"
  assume_role_policy = jsonencode({
    Version   = "2012-10-17",
    Statement = [{
      Effect    = "Allow",
      Principal = { Service = "scheduler.amazonaws.com" },
      Action    = "sts:AssumeRole"
    }]
  })
}
resource "aws_scheduler_schedule" "confluence_sync" {
  name       = "${local.name_prefix}-confluence-sync-schedule"
  group_name = "default"

  flexible_time_window {
    mode = "OFF"
  }

  schedule_expression = var.confluence_sync_schedule

  target {
    arn      = module.rag_pipeline.confluence_checker_lambda_arn
    role_arn = aws_iam_role.scheduler_role.arn
  }
}
resource "aws_iam_role_policy" "scheduler_policy" {
  name = "${local.name_prefix}-scheduler-policy"
  role = aws_iam_role.scheduler_role.id
  policy = jsonencode({
    Version   = "2012-10-17",
    Statement = [{
      Effect   = "Allow",
      Action   = "lambda:InvokeFunction",
      Resource = module.rag_pipeline.confluence_checker_lambda_arn
    }]
  })
}
resource "aws_s3_bucket" "lambda_code" {
  bucket = var.lambda_code_bucket_name
}

resource "aws_s3_bucket" "monolith_assets" {
  bucket = "${local.name_prefix}-monolith-assets"
}

data "archive_file" "dummy_lambda_zip" {
  type        = "zip"
  output_path = "${path.module}/dummy_lambda.zip"

  source {
    content  = "exports.handler = async (event) => {};"
    filename = "index.js"
  }
}

resource "aws_s3_object" "chunk_lambda_code" {
  bucket = aws_s3_bucket.lambda_code.id
  key    = var.chunk_lambda_s3_key
  source = data.archive_file.dummy_lambda_zip.output_path
  etag   = filemd5(data.archive_file.dummy_lambda_zip.output_path)
}

resource "aws_s3_object" "embed_lambda_code" {
  bucket = aws_s3_bucket.lambda_code.id
  key    = var.embed_lambda_s3_key
  source = data.archive_file.dummy_lambda_zip.output_path
  etag   = filemd5(data.archive_file.dummy_lambda_zip.output_path)
}

module "vpc" {
  source                   = "../../modules/vpc"
  name                     = local.name_prefix
  cidr                     = var.vpc_cidr
  public_subnet_cidrs      = var.public_subnet_cidrs
  private_app_subnet_cidrs = var.private_app_subnet_cidrs
  private_rag_subnet_cidrs = var.private_rag_subnet_cidrs
  region                   = var.region
}

module "ingress" {
  source                      = "../../modules/ingress"
  name                        = local.name_prefix
  priority_uploads_bucket_id  = module.rag_pipeline.priority_uploads_bucket_id
  priority_uploads_bucket_arn = module.rag_pipeline.priority_uploads_bucket_arn
  lambda_code_bucket          = aws_s3_bucket.lambda_code.id
  jwt_secret_arn              = module.data_services.secrets_manager_secret_arns_map["jwt_secret"]

  vpc_id                      = module.vpc.vpc_id
  public_subnet_ids           = module.vpc.public_subnet_ids
  alb_security_group_id       = module.vpc.alb_security_group_id
  acm_certificate_arn         = var.acm_certificate_arn # You'll need to add this variable

  depends_on = [
    aws_s3_object.generate_presigned_url_lambda_code
  ]
}

module "rag_pipeline" {
  source                 = "../../modules/rag_pipeline"
  name                   = local.name_prefix
  tenant_id              = var.tenant_id
  region                 = var.region
  private_subnet_ids     = module.vpc.private_rag_subnet_ids
  vpc_id                 = module.vpc.vpc_id
  chunk_lambda_s3_bucket = aws_s3_bucket.lambda_code.id
  chunk_lambda_s3_key    = var.chunk_lambda_s3_key

  embed_lambda_s3_bucket = aws_s3_bucket.lambda_code.id
  embed_lambda_s3_key    = var.embed_lambda_s3_key
  bedrock_embed_model_arn  = var.bedrock_embed_model_arn
  qdrant_api_key_secret_arn = module.data_services.secrets_manager_secret_arns_map["qdrant_api_key"]
  confluence_checker_lambda_s3_key = var.confluence_checker_lambda_s3_key
  confluence_api_key_secret_arn    = module.data_services.secrets_manager_secret_arns_map["confluence_api_key"]

  lambda_security_group_id  = module.vpc.rag_lambda_security_group_id
  
  depends_on = [
    aws_s3_object.chunk_lambda_code,
    aws_s3_object.embed_lambda_code,
    aws_s3_object.generate_presigned_url_lambda_code,
    aws_s3_object.confluence_checker_lambda_code
  ]
}

module "monolith_asg" {
  source                     = "../../modules/monolith_asg"
  name                       = "${local.name_prefix}-web"
  vpc_id                     = module.vpc.vpc_id
  private_subnet_ids         = module.vpc.private_app_subnet_ids
  instance_type              = var.web_instance_type
  min_size                   = var.web_min_size
  max_size                   = var.web_max_size
  desired_capacity           = var.web_desired_capacity
  assets_bucket              = aws_s3_bucket.monolith_assets.bucket
  sqs_queue_arn              = module.rag_pipeline.high_priority_queue_arn
  secrets_manager_secret_arn = module.data_services.secrets_manager_secret_arns_map["db_password"]
  region                     = var.region
  monolith_image_uri         = var.monolith_image_uri
  tenant_id                  = var.tenant_id
  target_group_arn      = module.ingress.monolith_target_group_arn
  alb_security_group_id = module.vpc.alb_security_group_id

}

module "agentic_asg" {
  source                            = "../../modules/agentic_asg"
  name                              = "${local.name_prefix}-agentic"
  vpc_id                            = module.vpc.vpc_id
  private_subnet_ids                = module.vpc.private_app_subnet_ids
  allowed_source_security_group_ids = [module.monolith_asg.security_group_id]
  instance_type                     = var.agentic_instance_type
  min_size                          = var.agentic_min_size
  max_size                          = var.agentic_max_size
  desired_capacity                  = var.agentic_desired_capacity
  s3_bucket_name                    = module.rag_pipeline.rag_chunks_bucket_name
  sqs_queue_url                     = module.rag_pipeline.high_priority_queue_url
  sqs_queue_arn                     = module.rag_pipeline.high_priority_queue_arn
  secrets_manager_secret_arn        = module.data_services.secrets_manager_secret_arns_map["db_password"]
  region                            = var.region
  agentic_image_uri                 = var.agentic_image_uri
  tenant_id                         = var.tenant_id
  deploy_key_secret_arn             = var.github_deploy_key_secret_arn

}

module "data_services" {
  source               = "../../modules/data_services"
  name                 = local.name_prefix
  tenant_id            = var.tenant_id
  vpc_id               = module.vpc.vpc_id
  private_subnet_ids   = module.vpc.private_app_subnet_ids
  region               = var.region
  qdrant_instance_type = var.qdrant_instance_type
  
  secrets = {
    "db_password"        = "changeme123"
    "qdrant_api_key"     = var.qdrant_api_key
    "jwt_secret"         = var.jwt_secret
    "confluence_api_key" = "your-confluence-api-key"
  }
}

module "iam" {
  source                     = "../../modules/iam"
  name                       = local.name_prefix
  region                     = var.region
  s3_bucket_name             = module.rag_pipeline.rag_chunks_bucket_name
  sqs_queue_arn              = module.rag_pipeline.high_priority_queue_arn
  secrets_manager_secret_arn = module.data_services.secrets_manager_secret_arns_map["db_password"]
}

resource "aws_security_group_rule" "agentic_to_data_qdrant" {
  type                     = "ingress"
  from_port                = 6333
  to_port                  = 6333
  protocol                 = "tcp"
  source_security_group_id = module.agentic_asg.security_group_id
  security_group_id        = module.data_services.data_services_security_group_id
  description              = "Allow Agentic ASG to Qdrant"
}
resource "aws_vpc" "main" {
  cidr_block = local.vpc_cidr

  tags = {
    Name = local.name
  }
}

### Public

resource "aws_subnet" "public" {
  vpc_id            = aws_vpc.main.id
  cidr_block        = cidrsubnet(local.vpc_cidr, 4, 0)
  availability_zone = "${data.aws_region.current.name}a"

  tags = {
    Name = "${local.name}-public"
  }
}

resource "aws_internet_gateway" "gw" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name = local.name
  }
}

resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name = "${local.name}-public"
  }
}

resource "aws_route" "public_igw" {
  route_table_id         = aws_route_table.public.id
  destination_cidr_block = "0.0.0.0/0"
  gateway_id             = aws_internet_gateway.gw.id

}

resource "aws_route_table_association" "public" {
  subnet_id      = aws_subnet.public.id
  route_table_id = aws_route_table.public.id
}

### Private

resource "aws_subnet" "private" {
  vpc_id            = aws_vpc.main.id
  cidr_block        = cidrsubnet(local.vpc_cidr, 4, 1)
  availability_zone = "${data.aws_region.current.name}a"

  tags = {
    Name = "${local.name}-private"
  }
}

resource "aws_route_table" "private" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name = "${local.name}-private"
  }
}

resource "aws_route_table_association" "private" {
  subnet_id      = aws_subnet.private.id
  route_table_id = aws_route_table.private.id
}
data "aws_availability_zone" "az" {
  for_each = toset(data.aws_availability_zones.azs.zone_ids)
  zone_id  = each.key
}

resource "aws_vpc" "main" {
  cidr_block = local.vpc_cidr

  tags = {
    Name = local.name
  }
}

### Public

resource "aws_subnet" "public" {
  for_each          = toset(data.aws_availability_zones.azs.zone_ids)
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.255.${substr(each.key, -1, -1)}.0/24"
  availability_zone = data.aws_availability_zone.az[each.key].name

  tags = {
    Name = "${local.name}-public-${each.key}"
  }
}

resource "aws_internet_gateway" "gw" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name = local.name
  }
}

resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name = "${local.name}-public"
  }
}

resource "aws_route" "public_igw" {
  route_table_id         = aws_route_table.public.id
  destination_cidr_block = "0.0.0.0/0"
  gateway_id             = aws_internet_gateway.gw.id
}

resource "aws_route_table_association" "public" {
  for_each       = toset(data.aws_availability_zones.azs.zone_ids)
  subnet_id      = aws_subnet.public[each.key].id
  route_table_id = aws_route_table.public.id
}

### Private

resource "aws_subnet" "private" {
  for_each          = toset(data.aws_availability_zones.azs.zone_ids)
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.255.${10 + substr(each.key, -1, -1)}.0/24"
  availability_zone = data.aws_availability_zone.az[each.key].name

  tags = {
    Name = "${local.name}-private-${each.key}"
  }
}

resource "aws_route_table" "private" {
  for_each = toset(data.aws_availability_zones.azs.zone_ids)
  vpc_id   = aws_vpc.main.id

  tags = {
    Name = "${local.name}-private-${each.key}"
  }
}

resource "aws_route_table_association" "private" {
  for_each       = toset(data.aws_availability_zones.azs.zone_ids)
  subnet_id      = aws_subnet.private[each.key].id
  route_table_id = aws_route_table.private[each.key].id
}
output "name" {
  description = "Name used for resources created within the module"
  value       = var.name
}

output "vpc_id" {
  description = "VPC ID to which the fck-nat instance is deployed into"
  value       = var.vpc_id
}

output "subnet_id" {
  description = "Subnet ID to which the fck-nat instance is deployed into"
  value       = var.subnet_id
}

output "encryption" {
  description = "Whether or not fck-nat instance EBS volumes are encrypted"
  value       = var.encryption
}

output "kms_key_id" {
  description = "KMS key ID to use for encrypting fck-nat instance EBS volumes"
  value       = var.kms_key_id
}

output "ha_mode" {
  description = "Whether or not high-availability mode is enabled via autoscaling group"
  value       = var.ha_mode
}

output "instance_type" {
  description = "Instance type used for the fck-nat instance"
  value       = aws_launch_template.main.instance_type
}

output "ami_id" {
  description = "AMI to use for the NAT instance. Uses fck-nat latest arm64 AMI in the region if none provided"
  value       = aws_launch_template.main.image_id
}

output "eni_id" {
  description = "The ID of the static ENI used by the fck-nat instance"
  value       = aws_network_interface.main.id
}

output "eni_arn" {
  description = "The ARN of the static ENI used by the fck-nat instance"
  value       = aws_network_interface.main.arn
}

output "security_group_id" {
  description = "Deprecated. The ID of the security group used by fck-nat ENIs"
  value       = aws_security_group.main.id
}

output "security_group_ids" {
  description = "List of security group IDs used by fck-nat ENIs"
  value       = local.security_groups
}

output "role_arn" {
  description = "The ARN of the role used by the fck-nat instance profile"
  value       = aws_iam_role.main.arn
}

output "instance_profile_arn" {
  description = "The ARN of the instance profile used by the fck-nat instance"
  value       = aws_iam_instance_profile.main.arn
}

output "launch_template_id" {
  description = "The ID of the launch template used to spawn fck-nat instances"
  value       = aws_launch_template.main.arn
}

output "instance_arn" {
  description = "The ARN of the fck-nat instance if running in non-HA mode"
  value       = var.ha_mode ? null : aws_instance.main[0].arn
}

output "instance_public_ip" {
  description = "The public IP address of the fck-nat instance if running in non-HA mode"
  value       = var.ha_mode ? null : aws_instance.main[0].public_ip
}

output "autoscaling_group_arn" {
  description = "The ARN of the autoscaling group if running in HA mode"
  value       = var.ha_mode ? aws_autoscaling_group.main[0].arn : null
}

output "cw_agent_config_ssm_parameter_arn" {
  description = "The ARN of the SSM parameter containing the Cloudwatch agent config"
  value       = local.cwagent_param_arn
}# modules/agentic_asg/outputs.tf

output "asg_name" {
  description = "Name of the Agentic Auto Scaling Group"
  value       = aws_autoscaling_group.agentic_asg.name
}

output "security_group_id" {
  description = "Security Group ID for Agentic instances"
  value       = aws_security_group.agentic_sg.id
}

# ADDED: Output for the new ECR repository URI.
output "agentic_ecr_uri" {
  description = "The URI of the ECR repository for the agentic container."
  value       = aws_ecr_repository.agentic.repository_url
}
# modules/rag_pipeline/outputs.tf

output "rag_chunks_bucket_name" {
  description = "Name of S3 bucket for processed RAG chunks"
  value       = aws_s3_bucket.rag_chunks.bucket
}

output "priority_uploads_bucket_id" {
  description = "ID of the S3 bucket for priority uploads"
  value       = aws_s3_bucket.priority_uploads.id
}

output "priority_uploads_bucket_arn" {
  description = "ARN of the S3 bucket for priority uploads"
  value       = aws_s3_bucket.priority_uploads.arn
}

output "high_priority_queue_url" {
  description = "URL of main RAG SQS queue"
  value       = aws_sqs_queue.high_priority_queue.id
}

output "high_priority_queue_arn" {
  description = "ARN of main RAG SQS queue"
  value       = aws_sqs_queue.high_priority_queue.arn
}

output "dlq_arn" {
  description = "ARN of dead-letter queue"
  value       = aws_sqs_queue.dlq.arn
}

output "confluence_checker_lambda_arn" {
  description = "The ARN of the Confluence Checker Lambda function."
  value       = aws_lambda_function.confluence_checker.arn
}# modules/vpc/outputs.tf

output "vpc_id" {
  value = aws_vpc.this.id
}

output "public_subnet_ids" {
  value = aws_subnet.public[*].id
}

output "private_app_subnet_ids" {
  value = aws_subnet.private_app[*].id
}

output "private_rag_subnet_ids" {
  value = aws_subnet.private_rag[*].id
}
output "rag_lambda_security_group_id" {
  description = "The ID of the security group for the RAG pipeline Lambdas."
  value       = aws_security_group.rag_lambda_sg.id
}
output "alb_security_group_id" {
  description = "The ID of the security group for the Application Load Balancer."
  value       = aws_security_group.alb_sg.id
}
output "fck_nat_security_group_id" {
  description = "The ID of the security group used by the fck-nat instance."
  value       = module.fck_nat.security_group_id
}# modules/monolith_asg/outputs.tf

output "asg_name" {
  description = "Name of the Monolith Auto Scaling Group"
  value       = aws_autoscaling_group.monolith_asg.name
}

output "security_group_id" {
  description = "Security Group ID for Monolith instances"
  value       = aws_security_group.monolith.id
}

# ADDED: Output for the new ECR repository URI.
output "monolith_ecr_uri" {
  description = "The URI of the ECR repository for the monolith container."
  value       = aws_ecr_repository.monolith.repository_url
}
# modules/ingress/outputs.tf

output "api_gateway_invoke_url" {
  description = "The invoke URL for the API Gateway."
  value       = aws_api_gateway_rest_api.this.execution_arn
}
output "alb_dns_name" {
  description = "The DNS name of the Application Load Balancer."
  value       = aws_lb.this.dns_name
}
output "monolith_target_group_arn" {
  description = "The ARN of the monolith target group."
  value       = aws_lb_target_group.monolith.arn
}# modules/data_services/outputs.tf

output "qdrant_instance_private_ip" {
  description = "The private IP address of the Qdrant EC2 instance."
  value       = aws_instance.qdrant.private_ip
}

output "secrets_manager_secret_arns" {
  value       = [for s in aws_secretsmanager_secret.this : s.arn]
  description = "ARNs of created Secrets"
}

# ADDED: A map of secret names to their ARNs for easier lookup.
output "secrets_manager_secret_arns_map" {
  value       = { for k, s in aws_secretsmanager_secret.this : k => s.arn }
  description = "Map of secret names to their ARNs"
}

output "data_services_security_group_id" {
  description = "Security Group for Redis & Qdrant"
  value       = aws_security_group.data_services_sg.id
}
output "alb_dns"          { value = module.ingress.alb_dns_name }
output "api_gateway_url"  { value = module.ingress.api_gateway_invoke_url }
output "web_asg_name"     { value = module.monolith_asg.asg_name }
output "rag_queue_url"    { value = module.rag_pipeline.queue_url }
# envs/dev/outputs.tf

# The 'ingress' module is commented out in main.tf, so these outputs are invalid.
# output "alb_dns"          { value = module.ingress.alb_dns_name }
# output "api_gateway_url"  { value = module.ingress.api_gateway_invoke_url }

output "web_asg_name" {
  value = module.monolith_asg.asg_name
}

output "rag_queue_url" {
   value = module.rag_pipeline.high_priority_queue_url
}
provider "aws" {
  region = var.region
  default_tags {
    tags = {
      Project     = var.project
      Environment = var.environment
      Tenant      = var.tenant_id
    }
  }
}
# envs/dev/provider.tf
provider "aws" {
  region = var.region
  default_tags {
    tags = {
      Project     = var.project
      Environment = var.environment
      Tenant      = var.tenant_id
    }
  }
}
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 4.0"
    }
  }
  required_version = "~> 1.3"
}terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 4.0"
    }
  }
}
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 4.0"
    }
  }
}
# modules/agentic_asg/variables.tf

variable "name" {
  type = string
}

variable "vpc_id" {
  type = string
}

variable "private_subnet_ids" {
  type = list(string)
}

variable "allowed_source_security_group_ids" {
  type = list(string)
}

variable "instance_type" {
  type    = string
  default = "t4g.small"
}

variable "min_size" {
  type    = number
  default = 1
}

variable "max_size" {
  type    = number
  default = 4
}

variable "desired_capacity" {
  type    = number
  default = 1
}

variable "s3_bucket_name" {
  type = string
}

variable "sqs_queue_arn" {
  type = string
}

variable "sqs_queue_url" {
  type = string
}

variable "secrets_manager_secret_arn" {
  type = string
}

variable "region" {
  type    = string
  default = "eu-central-1"
}

variable "agentic_image_uri" {
  description = "Optional full image URI for the agentic container to pull and run. If empty, no container will be launched."
  type        = string
  default     = ""
}

variable "tenant_id" {
  description = "The tenant identifier, used for naming and resource tagging."
  type        = string
}

variable "deploy_key_secret_arn" {
  description = "The ARN of the Secrets Manager secret for the GitHub deploy key."
  type        = string
}# modules/rag_pipeline/variables.tf

variable "name" {
  description = "Prefix (project-env-tenant) for all RAG resources"
  type        = string
}

variable "tenant_id" {
  description = "Tenant identifier (passed to Lambdas)"
  type        = string
}

variable "region" {
  description = "AWS Region"
  type        = string
  default     = "eu-central-1"
}

variable "vpc_id" {
  description = "VPC ID for RAG Lambdas"
  type        = string
}

variable "private_subnet_ids" {
  description = "Subnets for VPC-enabled Lambdas"
  type        = list(string)
}

# Lambda code locations
variable "chunk_lambda_s3_bucket" {
  type = string
}

variable "chunk_lambda_s3_key" {
  type = string
}

variable "embed_lambda_s3_bucket" {
  description = "The S3 bucket for the embed lambda function code."
  type        = string
}

variable "embed_lambda_s3_key" {
  description = "The S3 key for the embed lambda function code."
  type        = string
}

variable "lambda_security_group_id" {
  description = "The security group ID to assign to the VPC-enabled Lambdas."
  type        = string
}

variable "bedrock_embed_model_arn" {
  description = "The ARN of the Bedrock model to use for embeddings."
  type        = string
}

# ADDED: Variable for the Qdrant API key secret ARN.
variable "qdrant_api_key_secret_arn" {
  description = "The ARN of the Secrets Manager secret containing the Qdrant API key."
  type        = string
}

variable "confluence_checker_lambda_s3_key" {
  description = "The S3 key for the Confluence checker lambda function code."
  type        = string
}

variable "confluence_api_key_secret_arn" {
  description = "The ARN of the Secrets Manager secret for the Confluence API key."
  type        = string
}# envs/dev/variables.tf

variable "project" {
  type    = string
  default = "myapp"
}

variable "environment" {
  type    = string
  default = "dev"
}

variable "tenant_id" {
  type    = string
  default = "T001"
}

variable "region" {
  type    = string
  default = "eu-central-1"
}

# VPC
variable "vpc_cidr" {
  type    = string
  default = "10.0.0.0/16"
}

variable "public_subnet_cidrs" {
  type    = list(string)
  default = ["10.0.1.0/24", "10.0.2.0/24"]
}

variable "private_app_subnet_cidrs" {
  type    = list(string)
  default = ["10.0.11.0/24", "10.0.12.0/24"]
}

variable "private_rag_subnet_cidrs" {
  type    = list(string)
  default = ["10.0.21.0/24", "10.0.22.0/24"]
}

# Web ASG sizing
variable "web_instance_type" {
  description = "Instance type for the monolith web server."
  type        = string
  default     = "t4g.micro"
}

variable "web_min_size" {
  type    = number
  default = 1
}

variable "web_max_size" {
  type    = number
  default = 2
}

variable "web_desired_capacity" {
  type    = number
  default = 1
}

# RAG code locations
variable "lambda_code_bucket_name" {
  description = "The name of the S3 bucket for Lambda function code."
  type        = string
  default     = "myapp-lambda-code-dev"
}

variable "chunk_lambda_s3_key" {
  type    = string
  default = "chunk.zip"
}

variable "index_lambda_s3_key" {
  type    = string
  default = "index.zip"
}

# Agentic ASG sizing
variable "agentic_instance_type" {
  description = "Instance type for the agentic logic server."
  type        = string
  default     = "t4g.micro"
}

variable "agentic_min_size" {
  type    = number
  default = 1
}

variable "agentic_max_size" {
  type    = number
  default = 2
}

variable "agentic_desired_capacity" {
  type    = number
  default = 1
}

variable "qdrant_instance_type" {
  description = "Instance type for the Qdrant EC2 instance."
  type        = string
  default     = "t4g.micro"
}

variable "monolith_image_uri" {
  description = "Optional: The full URI of the monolith Docker image in ECR. Leave empty to skip."
  type        = string
  default     = ""
}

variable "agentic_image_uri" {
  description = "Optional: The full URI of the agentic Docker image in ECR. Leave empty to skip."
  type        = string
  default     = ""
}


variable "qdrant_api_key" {
  description = "The API key for the Qdrant vector database."
  type        = string
  sensitive   = true
  default     = "please-change-this-insecure-default-key"
}

variable "jwt_secret" {
  description = "A secret key used for signing JWTs for the ContextToken."
  type        = string
  sensitive   = true
  default     = "a-very-insecure-default-secret-for-dev"
}

variable "bedrock_embed_model_arn" {
  description = "The ARN of the Bedrock model to use for embeddings."
  type        = string
  default     = "arn:aws:bedrock:eu-central-1::foundation-model/amazon.titan-embed-text-v1"
}
variable "embed_lambda_s3_key" {
  type    = string
  default = "embed.zip"
}

variable "confluence_checker_lambda_s3_key" {
  description = "The S3 key for the Confluence checker lambda function code."
  type        = string
  default     = "confluence_checker.zip"
}

variable "confluence_sync_schedule" {
  description = "The cron expression for the Confluence sync schedule."
  type        = string
  default     = "cron(0 12 * * ? *)" # Once a day at noon UTC
}
variable "acm_certificate_arn" {
  description = "The ARN of the ACM certificate for the ALB listener."
  type        = string
  default     = "arn:aws:acm:eu-central-1:218160093341:certificate/4dbe94fe-e3b7-4812-8f0f-025140c44bed"
}
variable "my_ips_for_ssh" {
  description = "List of public IP addresses allowed to SSH into the jump host."
  type        = list(string)
  default     = ["87.150.125.128/32","95.91.247.58/32"]
}
variable "github_deploy_key_secret_arn" {
  description = "The ARN of the pre-existing Secrets Manager secret for the GitHub deploy key."
  type        = string
  # Example default value. Replace this with your actual secret ARN.
  default     = "arn:aws:secretsmanager:eu-central-1:218160093341:secret:magi_deploy_key-13sGjg"
}

variable "name" {
  type = string
}

variable "cidr" {
  type = string
}

variable "public_subnet_cidrs" {
  type = list(string)
}

variable "private_app_subnet_cidrs" {
  type = list(string)
}

variable "private_rag_subnet_cidrs" {
  type = list(string)
}

# ADDED: This variable was used in main.tf for endpoints but was not declared.
variable "region" {
  description = "The AWS region to create VPC endpoints in."
  type        = string
}
# modules/iam/variables.tf

# ADDED: These variables were being used but were not declared.
variable "name" {
  description = "A name prefix for the IAM resources."
  type        = string
}

variable "s3_bucket_name" {
  description = "The name of the S3 bucket for which to grant permissions."
  type        = string
}

variable "sqs_queue_arn" {
  description = "The ARN of the SQS queue for which to grant permissions."
  type        = string
}

variable "secrets_manager_secret_arn" {
  description = "The ARN of the Secrets Manager secret to grant access to."
  type        = string
}

variable "region" {
  description = "The AWS region where resources are deployed."
  type        = string
}
# modules/monolith_asg/variables.tf

variable "name" {
  type = string
}

variable "vpc_id" {
  type = string
}

variable "private_subnet_ids" {
  type = list(string)
}

variable "instance_type" {
  type = string
}

variable "min_size" {
  type = number
}

variable "max_size" {
  type = number
}

variable "desired_capacity" {
  type = number
}

variable "assets_bucket" {
  type = string
}

variable "sqs_queue_arn" {
  type = string
}

variable "secrets_manager_secret_arn" {
  type = string
}

variable "region" {
  type    = string
  default = "eu-central-1"
}

variable "monolith_image_uri" {
  description = "Optional full image URI for the monolith container to pull and run. If empty, no container will be launched."
  type        = string
  default     = ""
}
variable "tenant_id" {
  description = "The tenant identifier, used for naming and resource tagging."
  type        = string
}
variable "target_group_arn" {
  description = "The ARN of the ALB target group to attach the ASG to."
  type        = string
}

variable "alb_security_group_id" {
  description = "The ID of the ALB's security group to allow ingress traffic from."
  type        = string
}# modules/ingress/variables.tf

variable "name" {
  description = "A name prefix for all resources."
  type        = string
}

variable "priority_uploads_bucket_id" {
  description = "The ID of the S3 bucket for priority file uploads."
  type        = string
}

variable "priority_uploads_bucket_arn" {
  description = "The ARN of the S3 bucket for priority file uploads."
  type        = string
}

variable "lambda_code_bucket" {
  description = "The S3 bucket containing the Lambda function code."
  type        = string
}

# UPDATED: Changed from passing the raw secret to passing its secure ARN.
variable "jwt_secret_arn" {
  description = "The ARN of the Secrets Manager secret for the JWT key."
  type        = string
  sensitive   = true
}
variable "vpc_id" {
  description = "The ID of the VPC."
  type        = string
}

variable "public_subnet_ids" {
  description = "A list of public subnet IDs for the ALB."
  type        = list(string)
}

variable "alb_security_group_id" {
  description = "The ID of the security group for the ALB."
  type        = string
}

variable "acm_certificate_arn" {
  description = "The ARN of the ACM certificate for HTTPS."
  type        = string
}
# modules/data_services/variables.tf

variable "name" {
  description = "Prefix (project-env-tenant) for data services"
  type        = string
}

variable "tenant_id" {
  description = "Tenant identifier"
  type        = string
}

variable "vpc_id" {
  description = "VPC ID"
  type        = string
}

variable "private_subnet_ids" {
  description = "Subnets for ElastiCache & ECS"
  type        = list(string)
}

variable "region" {
  description = "AWS Region"
  type        = string
  default     = "us-east-1"
}

# ADDED: Variable for the Qdrant instance type.
variable "qdrant_instance_type" {
  description = "Instance type for the Qdrant EC2 instance."
  type        = string
  default     = "t4g.small"
}

variable "qdrant_container_image" {
  description = "Docker image for Qdrant"
  type        = string
  default     = "qdrant/qdrant:latest"
}

variable "secrets" {
  description = "Map of secret names  initial values (optional)"
  type        = map(string)
  default     = {}
}
# envs/prod/variables.tf

variable "project" {
  type    = string
  default = "myapp"
}

variable "environment" {
  type    = string
  default = "prod"
}

variable "tenant_id" {
  type    = string
  default = "T001"
}

variable "region" {
  type    = string
  default = "eu-central-1"
}

# VPC
variable "vpc_cidr" {
  type    = string
  default = "10.0.0.0/16"
}

variable "public_subnet_cidrs" {
  type    = list(string)
  default = ["10.0.1.0/24", "10.0.2.0/24"]
}

variable "private_app_subnet_cidrs" {
  type    = list(string)
  default = ["10.0.11.0/24", "10.0.12.0/24"]
}

variable "private_rag_subnet_cidrs" {
  type    = list(string)
  default = ["10.0.21.0/24", "10.0.22.0/24"]
}

# NAT scheduling (optional tweak)
variable "nat_on_time" {
  type    = string
  default = "cron(0 7 * * ? *)"
}

variable "nat_off_time" {
  type    = string
  default = "cron(0 19 * * ? *)"
}

# Web ASG sizing
variable "web_instance_type" {
  type    = string
  default = "t3.medium"
}

variable "web_min_size" {
  type    = number
  default = 1
}

variable "web_max_size" {
  type    = number
  default = 2
}

variable "web_desired_capacity" {
  type    = number
  default = 1
}

# RAG code locations
variable "chunk_lambda_s3_bucket" {
  type    = string
  default = "myapp-lambda-code"
}

variable "chunk_lambda_s3_key" {
  type    = string
  default = "chunk.zip"
}

variable "embed_lambda_s3_bucket" {
  type    = string
  default = "myapp-lambda-code"
}

variable "embed_lambda_s3_key" {
  type    = string
  default = "embed.zip"
}

variable "index_lambda_s3_bucket" {
  type    = string
  default = "myapp-lambda-code"
}

variable "index_lambda_s3_key" {
  type    = string
  default = "index.zip"
}

# Agentic ASG sizing
variable "agentic_instance_type" {
  type    = string
  default = "t3.medium"
}

variable "agentic_min_size" {
  type    = number
  default = 1
}

variable "agentic_max_size" {
  type    = number
  default = 2
}

variable "agentic_desired_capacity" {
  type    = number
  default = 1
}
variable "name" {
  description = "Name used for resources created within the module"
  type        = string
}

variable "vpc_id" {
  description = "VPC ID to deploy the NAT instance into"
  type        = string
}

variable "subnet_id" {
  description = "Subnet ID to deploy the NAT instance into"
  type        = string
}

variable "update_route_table" {
  description = "Deprecated. Use update_route_tables instead"
  type        = bool
  default     = false
}

variable "update_route_tables" {
  description = "Whether or not to update the route tables with the NAT instance"
  type        = bool
  default     = false
}

variable "route_table_id" {
  description = "Deprecated. Use route_tables_ids instead"
  type        = string
  default     = null
}

variable "route_tables_ids" {
  description = "Route tables to update. Only valid if update_route_tables is true"
  type        = map(string)
  default     = {}
}

variable "encryption" {
  description = "Whether or not to encrypt the EBS volume"
  type        = bool
  default     = true
}

variable "kms_key_id" {
  description = "Will use the provided KMS key ID to encrypt the EBS volume. Uses the default KMS key if none provided"
  type        = string
  default     = null
}

variable "ha_mode" {
  description = "Whether or not high-availability mode should be enabled via autoscaling group"
  type        = bool
  default     = true
}

variable "instance_type" {
  description = "Instance type to use for the NAT instance"
  type        = string
  default     = "t4g.micro"
}

variable "ami_id" {
  description = "AMI to use for the NAT instance. Uses fck-nat latest AMI in the region if none provided"
  type        = string
  default     = null
}

variable "ebs_root_volume_size" {
  description = "Size of the EBS root volume in GB"
  type        = number
  default     = 8
}

variable "eip_allocation_ids" {
  description = "EIP allocation IDs to use for the NAT instance. Automatically assign a public IP if none is provided. Note: Currently only supports at most one EIP allocation."
  type        = list(string)
  default     = []
}

variable "attach_ssm_policy" {
  description = "Whether to attach the minimum required IAM permissions to connect to the instance via SSM."
  type        = bool
  default     = true
}

variable "use_spot_instances" {
  description = "Whether or not to use spot instances for running the NAT instance"
  type        = bool
  default     = false
}

variable "use_cloudwatch_agent" {
  description = "Whether or not to enable CloudWatch agent for the NAT instance"
  type        = bool
  default     = false
}

variable "cloudwatch_agent_configuration" {
  description = "CloudWatch configuration for the NAT instance"
  type = object({
    namespace           = optional(string, "fck-nat"),
    collection_interval = optional(number, 60),
    endpoint_override   = optional(string, "")
  })
  default = {
    namespace           = "fck-nat"
    collection_interval = 60
    endpoint_override   = ""
  }
}

variable "cloudwatch_agent_configuration_param_arn" {
  description = "ARN of the SSM parameter containing the CloudWatch agent configuration. If none provided, creates one"
  type        = string
  default     = null
}

variable "use_default_security_group" {
  description = "Whether or not to use the default security group for the NAT instance"
  type        = bool
  default     = true
}

variable "additional_security_group_ids" {
  description = "A list of identifiers of security groups to be added for the NAT instance"
  type        = list(string)
  default     = []
}

variable "use_ssh" {
  description = "Whether or not to enable SSH access to the NAT instance"
  type        = bool
  default     = false
}

variable "ssh_key_name" {
  description = "Name of the SSH key to use for the NAT instance. SSH access will be enabled only if a key name is provided"
  type        = string
  default     = null
}

variable "ssh_cidr_blocks" {
  description = "CIDR blocks to allow SSH access to the NAT instance from"
  type = object({
    ipv4 = optional(list(string), [])
    ipv6 = optional(list(string), [])
  })
  default = {
    ipv4 = [],
    ipv6 = []
  }
}

variable "tags" {
  description = "Tags to apply to resources created within the module"
  type        = map(string)
  default     = {}
}